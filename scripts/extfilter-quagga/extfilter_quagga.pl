#!/usr/bin/perl

# создаем нужные файлы из БД rkn
# Внимание!!! IP адреса в базе должны храниться в виде байт, а не целого числа.

use strict;
use warnings;
use utf8;
use Config::Simple;
use DBI;
use File::Basename;
use URI;
use POSIX;
use Digest::MD5 qw (md5);
use Log::Log4perl;
use Net::IP qw(:PROC);
use Encode;
use Net::CIDR::Lite;
use IPC::Open2;
use Fcntl qw(LOCK_EX LOCK_NB);

binmode(STDOUT,':utf8');
binmode(STDERR,':utf8');

my $dir = File::Basename::dirname($0);

my $Config = {};
Config::Simple->import_from($dir.'/extfilter_quagga.conf', $Config) or die "Can't open ".$dir."/extfilter_quagga.conf for reading!\n";
Log::Log4perl::init( $dir."/extfilter_quagga_log.conf" );

my $logger=Log::Log4perl->get_logger();

my $send_mail = $Config->{'NOTIFY.send_mail'} || 0;
$send_mail = lc($send_mail);
my $notify_to = $Config->{'NOTIFY.to'} || "";
my $notify_from = $Config->{'NOTIFY.from'} || "";

if(!flock(DATA,LOCK_EX|LOCK_NB))
{
	$logger->error("Process already running!");
	print STDERR "Process already running!\n";
	if(($send_mail eq "1" || $send_mail eq "true") && $notify_to ne "" && $notify_from ne "")
	{
		open(MAIL, "|/bin/mail -t");
		print MAIL "To: $notify_to\n";
		print MAIL "From: $notify_from\n";
		print MAIL "Subject: BGP Alert!\n\n";
		print MAIL "BGP maker process already running! Check it!\n\n";
	}
	exit 1;
}

my $db_host = $Config->{'DB.host'} || die "DB.host not defined.";
my $db_user = $Config->{'DB.user'} || die "DB.user not defined.";
my $db_pass = $Config->{'DB.password'} || die "DB.password not defined.";
my $db_name = $Config->{'DB.name'} || die "DB.name not defined.";

# пути к генерируемым файлам:
my $bgpd_file = $Config->{'BGP.quagga_config'} || "";

my $bgp_as = $Config->{'BGP.our_as'} || "";
my $bgp_router_id = $Config->{'BGP.router_id'} || "";
my $bgp_neighbor = $Config->{'BGP.neighbor'} || "";
my $bgp_remote_as = $Config->{'BGP.remote_as'} || "";
my $bgp6_neighbor = $Config->{'BGP.neighbor6'} || "";
my $vtysh = $Config->{'BGP.vtysh'} || "/bin/vtysh";
my $route_to_null = (lc($Config->{'BGP.route_to_null'} || "true")) eq "true" ? 1 : 0;
my $do_subnets = (lc($Config->{'BGP.do_subnets'} || "true")) eq "true" ? 1 : 0;

my $update_soft_quagga=1;

my $dbh = DBI->connect("DBI:mysql:database=".$db_name.";host=".$db_host,$db_user,$db_pass,{mysql_enable_utf8 => 1}) or die DBI->errstr;
$dbh->do("set names utf8");


my $only_ip=0;
my %ip_s;
my %ip6_s;
my %ip_s_null;
my %ip6_s_null;
my %already_out;

my $ip_cidr=new Net::CIDR::Lite;
my $ip_cidr_null=new Net::CIDR::Lite;
my $ip6_cidr=new Net::CIDR::Lite;
my $ip6_cidr_null=new Net::CIDR::Lite;

my @ip_list;
my @ip6_list;
my @ip_list_null;
my @ip6_list_null;

my $net_file_hash_old=get_md5_sum($bgpd_file);

my $cmd = "$vtysh -c 'show run'";
my $show_run=`$cmd`;
if ( $? == -1 )
{
	$logger->error("Error while executed cmd $cmd: $!, skip soft Quagga reconfiguration");
	$update_soft_quagga=0;
}

my $NET_FILE;
if(!$update_soft_quagga)
{
	open ($NET_FILE, ">",$bgpd_file) or die "Could not open file '$bgpd_file' $!";
	print $NET_FILE "! Generated by super-puper script\n!\n!\nrouter bgp $bgp_as\n bgp router-id $bgp_router_id\n neighbor $bgp_neighbor remote-as $bgp_remote_as\n neighbor $bgp6_neighbor remote-as $bgp_remote_as\n no neighbor $bgp6_neighbor activate\n";
}


my $cur_time=strftime "%F %T", localtime $^T;

my %http_add_ports;
my %https_add_ports;

my %ssl_hosts;
my %ssl_ip;

my $sth = $dbh->prepare("SELECT ip FROM zap2_only_ips");
$sth->execute;
while (my $ips = $sth->fetchrow_hashref())
{
	my $ip=get_ip($ips->{ip});
	next if($ip eq "0.0.0.0" || $ip eq "0000:0000:0000:0000:0000:0000:0000:0000");
	if($ip =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/)
	{
		$ip_cidr_null->add_any($ip) if($route_to_null);
		$ip_cidr->add_any($ip);
	} else
	{
		$ip6_cidr_null->add_any($ip) if($route_to_null);
		$ip6_cidr->add_any($ip);
	}
}
$sth->finish();

if($do_subnets)
{
	$sth = $dbh->prepare("SELECT subnet FROM zap2_subnets");
	$sth->execute;
	while (my $ips = $sth->fetchrow_hashref())
	{
		my $subnet = $ips->{subnet};
		if($subnet =~ /(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/)
		{
			$ip_cidr_null->add_any($subnet) if($route_to_null);
			$ip_cidr->add_any($subnet);
		} else
		{
			$ip6_cidr_null->add_any($subnet) if($route_to_null);
			$ip6_cidr->add_any($subnet);
		}
	}
	$sth->finish();
}

@ip_list=$ip_cidr->list();
%ip_s = map { $_ => 1 } @ip_list;
@ip6_list=$ip6_cidr->list();
%ip6_s = map { $_ => 1 } @ip6_list;
@ip_list_null=$ip_cidr_null->list();
%ip_s_null = map { $_ => 1 } @ip_list_null;
@ip6_list_null=$ip6_cidr_null->list();
%ip6_s_null = map { $_ => 1 } @ip6_list_null;

if(!$update_soft_quagga)
{
	foreach my $ip (@ip_list)
	{
		print $NET_FILE " network $ip\n";
	}
	if(@ip6_list)
	{
		print $NET_FILE "address-family ipv6\n";
		print $NET_FILE " neighbor $bgp6_neighbor activate\n";
		foreach my $ip (@ip6_list)
		{
			print $NET_FILE " network $ip\n";
		}
		print $NET_FILE "exit-address-family\n";
	}
	foreach my $ip (@ip_list_null)
	{
		print $NET_FILE "ip route $ip Null0\n";
	}
	foreach my $ip (@ip6_list_null)
	{
		print $NET_FILE "ip route $ip Null0\n";
	}
	print $NET_FILE "!\nline vty\n!\n\n";
	close $NET_FILE;
} else {
	analyse_quagga_networks();
}

$dbh->disconnect();

my $net_file_hash=get_md5_sum($bgpd_file);

if(!$update_soft_quagga)
{
	if($net_file_hash ne $net_file_hash_old)
	{
		$logger->debug("Restarting bgpd...");
		system("/bin/systemctl", "restart","bgpd");
		if ( $? == -1 )
		{
			$logger->error("Bgpd restart failed: $!");
		} else {
			$logger->info("Bgpd successfully restarted!");
		}
	}
}

exit 0;

sub get_md5_sum
{
	my $file=shift;
	open(my $MFILE, $file) or die "Can't open '$file': $!";
	binmode($MFILE);
	my $hash=Digest::MD5->new->addfile(*$MFILE)->hexdigest;
	close($MFILE);
	return $hash;
}

sub get_ips_for_record_id
{
	my $record_id=shift;
	my @ips;
	my $sth = $dbh->prepare("SELECT ip FROM zap2_ips WHERE record_id=$record_id");
	$sth->execute;
	while (my $ips = $sth->fetchrow_hashref())
	{
		push(@ips,get_ip($ips->{ip}));
	}
	$sth->finish();
	return @ips;
}

sub get_ip
{
	my $ip_address=shift;
	my $d_size=length($ip_address);
	my $result;
	if($d_size == 4)
	{
		$result=ip_bintoip(unpack("B*",$ip_address),4);
	} else {
		$result=ip_bintoip(unpack("B*",$ip_address),6);
	}
	return $result;
}

sub analyse_quagga_networks
{
	my $need_save_config=0;

	my %ips_to_add = %ip_s;
	my %ips6_to_add = %ip6_s;
	my %ips_to_add_null=%ip_s_null;
	my %ips6_to_add_null=%ip6_s_null;

	my %ips_to_del;
	my %ips6_to_del;
	my %ips_to_del_null;
	my %ips6_to_del_null;

	foreach my $line (split /\n/ ,$show_run)
	{
		next if ($line =~ /^\s*\!/);
		if($line =~ /^\s*network\s+(.+)\/(\d+)/)
		{
			my $address=$1;
			my $mask=$2;
			my $ip_version=ip_get_version($address);
			my $ip_a = new Net::IP ("$address/$mask");
			my $ip_p = $ip_a->print();
			if($ip_version == 4)
			{
				$ip_p = "$address/$mask";
				if(defined $ip_s{$ip_p})
				{
					delete $ips_to_add{$ip_p};
				} else {
					$ips_to_del{$ip_p}=1;
				}
			} elsif ($ip_version == 6)
			{
				if(defined $ip6_s{$ip_p})
				{
					delete $ips6_to_add{$ip_p};
				} else {
					$ips6_to_del{$ip_p}=1;
				}
			}
		}
		if($route_to_null && $line =~ /^ip\s+route\s+(.+)\/(\d+)/)
		{
			my $address=$1;
			my $mask=$2;
			my $ip_version=ip_get_version($address);
			my $ip_a = new Net::IP ("$address/$mask");
			my $ip_p = $ip_a->print();
			if($ip_version == 4)
			{
				$ip_p = "$address/$mask";
				if(defined $ip_s_null{$ip_p})
				{
					delete $ips_to_add_null{$ip_p};
				} else {
					$ips_to_del_null{$ip_p}=1;
				}
			} elsif ($ip_version == 6)
			{
				if(defined $ip6_s_null{$ip_p})
				{
					delete $ips6_to_add_null{$ip_p};
				} else {
					$ips6_to_del_null{$ip_p}=1;
				}
			}
		}
	}

	if((scalar keys %ips_to_add) || (scalar keys %ips6_to_add) || (scalar keys %ips_to_add_null) || (scalar keys %ips6_to_add_null) || (scalar keys %ips_to_del) || (scalar keys %ips6_to_del) || (scalar keys %ips_to_del_null) || (scalar keys %ips6_to_del_null))
	{
		my ($rdr,$wtr);
		my $pid=open2($rdr,$wtr, "$vtysh");
		my $outb;
		print $wtr "configure terminal\n";
		$outb=<$rdr>;
		# delete routes
		foreach my $ip (keys %ips_to_del_null)
		{
			print $wtr "no ip route $ip Null0\n";
			$outb=<$rdr>;
		}

		foreach my $ip (keys %ips6_to_del_null)
		{
			print $wtr "no ip route $ip Null0\n";
			$outb=<$rdr>;
		}
		# add routes
		foreach my $ip (keys %ips_to_add_null)
		{
			print $wtr "ip route $ip Null0\n";
			$outb=<$rdr>;
		}
		foreach my $ip (keys %ips6_to_add_null)
		{
			print $wtr "ip route $ip Null0\n";
			$outb=<$rdr>;
		}
		print $wtr "router bgp $bgp_as\n";
		$outb=<$rdr>;
		# delete networks
		foreach my $ip (keys %ips_to_del)
		{
			print $wtr "no network $ip\n";
			$outb=<$rdr>;
		}
		# add networks
		foreach my $ip (keys %ips_to_add)
		{
			print $wtr "network $ip\n";
			$outb=<$rdr>;
		}
		print $wtr "address-family ipv6\n";
		foreach my $ip (keys %ips6_to_del)
		{
			print $wtr "no network $ip\n";
			$outb=<$rdr>;
		}
		foreach my $ip (keys %ips6_to_add)
		{
			print $wtr "network $ip\n";
			$outb=<$rdr>;
		}
		print $wtr "end\n";
		$outb=<$rdr>;
		print $wtr "write mem\n";
		$outb=<$rdr>;
		print $wtr "exit\n";
		$outb=<$rdr>;
		close($wtr);
		close($rdr);

		waitpid( $pid, 0 );
		my $child_exit_status = $? >> 8;
		if($child_exit_status)
		{
			$logger->error("Error while excecuting vtysh commands");
		} else {
			$logger->info("Quagga configuration successfully updated: added ".(scalar keys %ips_to_add)." ipv4 ips, added ".(scalar keys %ips6_to_add)." ipv6 ips, deleted ".(scalar keys %ips_to_del)." ipv4 ips, deleted ".(scalar keys %ips6_to_del)." ipv6 ips, added ".(scalar keys %ips_to_add_null)." ipv4 routes to blackhole, added ".(scalar keys %ips6_to_add_null)." ipv6 routes to blackhole, deleted ".(scalar keys %ips_to_del_null)." ipv4 routes from blackhole, deleted ".(scalar keys %ips6_to_del_null)." ipv6 routes from blackhole.");
		}
	}
}

__DATA__
